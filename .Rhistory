install.packages("knitr")
install.packages("knitr")
install.packages("rmarkdown")
rmarkdown::render()
devtools::rmarkdown::render()
devtools::use_readme_rmd
help = package("collegestats")
devtools::document()
devtools::document()
devtools::install_github("azc242/collegestats")
help = package("collegestats")
help(package = "collegestats")
devtools::document()
devtools::document()
qnorm(.01)
pnorm(.05)
qnorm(.05)
beta = .4
beta = 1 - power
# 1e. find smallest sample size that will give type 2 error of .1 or less
alpha = .05
power = .6 # 1-beta, so beta is .4
beta = 1 - power
beta = .1
# 1e. find smallest sample size that will give type 2 error of .1 or less
alpha = .05
beta = .1
z_alpha = qnorm(1-alpha) # THIS IS ONLY FOR 1-SIDED TEST
z_alpha = qnorm(1-alpha) # THIS IS ONLY FOR 1-SIDED TEST
z_beta = qnorm(1-beta)
z_beta
z_alpha
Ho = .02
Ho = .02
p = .03
z_alpha = qnorm(1-alpha) # THIS IS ONLY FOR 1-SIDED TEST
z_beta = qnorm(1-beta)
n = (((z_beta * sqrt(p * (1 - p))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - p))^2
# 1e. find smallest sample size that will give type 2 error of .1 or less
alpha = .05
beta = .1
Ho = .02
p = .03
z_alpha = qnorm(1-alpha) # THIS IS ONLY FOR 1-SIDED TEST
z_beta = qnorm(1-beta)
n = (((z_beta * sqrt(p * (1 - p))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - p))^2
n
qnorm(.95)
qnorm(.975)
qnorm(1 - (1 - .95)/2)
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = (((z_beta * sqrt(Ha * (1 - Ha))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - p))^2
return(n)
if(is.null(sd)) {
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = (((z_beta * sqrt(Ha * (1 - Ha))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - p))^2
return(n)
}
# 1e. find smallest sample size that will give type 2 error of .1 or less
minSampSizeType2 <- function(alpha, beta, Ho, Ha, twoSided = FALSE, sd = NULL) {
if(is.null(sd)) {
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = (((z_beta * sqrt(Ha * (1 - Ha))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - p))^2
return(n)
}
else {
}
}
minSampSizeType2(alpha = .05, beta = .1, Ho = .02, Ha = .03)
cat("You haven't specified a 2 or 1 sided test. The program defaults to a 1 sided test.")
minSampSizeType2(alpha = .05, beta = .1, Ho = .02, Ha = .03)
minSampSizeType2(alpha = .05, beta = .1, Ho = .02, Ha = .03)
print("You haven't specified a 2 or 1 sided test. The program defaults to a 1 sided test.")
# 1e. find smallest sample size that will give type 2 error of .1 or less
minSampSizeType2 <- function(alpha, beta, Ho, Ha, twoSided = FALSE, sd = NULL) {
if(!twoSided) {
print("You haven't specified a 2 or 1 sided test. The program defaults to a 1 sided test.")
}
if(is.null(sd)) {
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = (((z_beta * sqrt(Ha * (1 - Ha))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - p))^2
return(n)
}
else {
}
}
minSampSizeType2(alpha = .05, beta = .1, Ho = .02, Ha = .03)
# 1e. find smallest sample size that will give type 2 error of .1 or less
minSampSizeType2 <- function(alpha, beta, Ho, Ha, twoSided = FALSE, sd = NULL) {
if(!twoSided) {
print("You haven't specified a 2 or 1 sided test. The program defaults to a 1 sided test.")
}
if(is.null(sd)) {
print("You have not specified a sd, this is when Ho and Ha are probabilities instead of numerical quantities.")
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = (((z_beta * sqrt(Ha * (1 - Ha))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - p))^2
return(n)
}
else {
}
}
minSampSizeType2(alpha = .05, beta = .1, Ho = .02, Ha = .03)
# 1e. find smallest sample size that will give type 2 error of .1 or less
minSampSizeType2 <- function(alpha, beta, Ho, Ha, twoSided = FALSE, sd = NULL) {
if(!twoSided) {
warning("You haven't specified a 2 or 1 sided test. The program defaults to a 1 sided test.")
}
if(is.null(sd)) {
print("You have not specified a sd, this is when Ho and Ha are probabilities instead of numerical quantities.")
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = (((z_beta * sqrt(Ha * (1 - Ha))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - p))^2
return(n)
}
else {
}
}
minSampSizeType2(alpha = .05, beta = .1, Ho = .02, Ha = .03)
# 1e. find smallest sample size that will give type 2 error of .1 or less
minSampSizeType2 <- function(alpha, beta, Ho, Ha, twoSided = FALSE, sd = NULL) {
if(!twoSided) {
message("You haven't specified a 2 or 1 sided test. The program defaults to a 1 sided test.")
}
if(is.null(sd)) {
print("You have not specified a sd, this is when Ho and Ha are probabilities instead of numerical quantities.")
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = (((z_beta * sqrt(Ha * (1 - Ha))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - p))^2
return(n)
}
else {
}
}
minSampSizeType2(alpha = .05, beta = .1, Ho = .02, Ha = .03)
# 1e. find smallest sample size that will give type 2 error of .1 or less
minSampSizeType2 <- function(alpha, beta, Ho, Ha, twoSided = FALSE, sd = NULL) {
if(!twoSided) {
message("You haven't specified a 2 or 1 sided test. The program defaults to a 1 sided test.")
}
if(is.null(sd)) {
message("You have not specified a sd, this is when Ho and Ha are probabilities instead of numerical quantities.")
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = (((z_beta * sqrt(Ha * (1 - Ha))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - p))^2
return(n)
}
else {
}
}
minSampSizeType2(alpha = .05, beta = .1, Ho = .02, Ha = .03)
# 1e. find smallest sample size that will give type 2 error of .1 or less
minSampSizeType2 <- function(alpha, beta, Ho, Ha, twoSided = FALSE, sd = NULL) {
if(!twoSided) {
message("You haven't specified a 2 or 1 sided test. The program defaults to a 1 sided test.")
}
if(is.null(sd)) {
message("You have not specified a sd, this is when Ho and Ha are probabilities instead of numerical quantities.")
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = (((z_beta * sqrt(Ha * (1 - Ha))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - Ha))^2
return(n)
}
else {
}
}
minSampSizeType2(alpha = .05, beta = .1, Ho = .02, Ha = .03)
# 2a.
Ho = 50000
n = 100
alpha = .05
x = 60000
z_score = qnorm(.05)
z_score
z_score = qnorm(1 -.05)
upper = Ho + z_score * sigma
# 2a.
Ho = 50000
n = 100
alpha = .05
sigma = 50000
x = 60000
z_score = qnorm(1 -.05)
upper = Ho + z_score * sigma
upper
upper = Ho + z_score * sigma
p = 60000
z_score = qnorm(1 -.05)
upper = Ho + z_score * sigma
1 - pnorm((upper - p)/sqrt(p * (1 - p)/n))
1 - pnorm((upper - p)/sqrt(sigma^2/n))
1 - pnorm((upper - p)/sqrt(sigma/n))
1 - pnorm((upper - p)/sigma)
s_sd = sigma/sqrt(n)
samp_sd = sigma/sqrt(n)
upper = Ho + z_score * samp_sd
# 2a.
Ho = 50000
n = 100
alpha = .05
sigma = 50000
samp_sd = sigma/sqrt(n)
p = 60000
z_score = qnorm(1 -.05)
upper = Ho + z_score * samp_sd
upper = Ho + z_score * samp_sd
1 - pnorm((upper - p)/samp_sd)
pnorm((upper - p)/samp_sd)
z_score = 1.645#qnorm(1 -.05)
upper = Ho + z_score * samp_sd
pnorm((upper - p)/samp_sd)
z_score = qnorm(1 -.05)
upper = Ho + z_score * samp_sd
pnorm((upper - p)/samp_sd)
#2b.
Ho = 50000
source('~/R-Workspace/11-2-lec.R', echo=TRUE)
n = 100
alpha = .1
samp_sd = simga/sqrt(n)
samp_sd = sigma/sqrt(n)
p = 60000
z_score = qnorm(1 - alpha)
z_score = qnorm(1 - alpha)
upper = Ho + z_score * samp_sd
pnorm((upper - p)/samp_sd)
#2b.
Ho = 50000
n = 100
alpha = .1
sigma = 50000
samp_sd = sigma/sqrt(n)
p = 60000
z_score = qnorm(1 - alpha)
upper = Ho + z_score * samp_sd
upper
pnorm((upper - p)/samp_sd)
# 2c.
Ho = 50000
sigma = 50000
n = 10000
samp_sd = sigma/sqrt(n)
alpha = .05
z_score = qnorm(1 - alpha)
upper = Ho + samp_sd * z_score
upper
p = 60000
z_score = qnorm(1 - alpha)
upper = Ho + samp_sd * z_score
pnorm((upper - p)/samp_sd)
# 2c.
Ho = 50000
sigma = 50000
n = 1000
samp_sd = sigma/sqrt(n)
alpha = .05
p = 60000
z_score = qnorm(1 - alpha)
upper = Ho + samp_sd * z_score
pnorm((upper - p)/samp_sd)
# 2d.
Ho = 50000
sigma = 50000
samp_sd = sigma/sqrt(n)
n = 1000
samp_sd = sigma/sqrt(n)
alpha = .01
p = 60000
z_score = qnorm(1 - alpha)
upper = Ho + samp_sd * z_score
upper
pnorm((upper - p)/samp_sd)
pnorm(-3.09)
1 - pnorm(-3.09)
pnorm(.86)
pnorm(.86) - pnorm(-3.09)
pnorm(.86) + (1- pnorm(-3.09))
1 - (pnorm(.86) + pnorm(-3.09))
1 - 0.1938937
zLess = pnorm((lower - p)/sqrt(p * (1 - p)/n))
zGreater = pnorm((upper - p)/sqrt(p * (1 - p)/n))
B = zGreater - zLess
return(B)
pnorm(.86) + -pnorm(-3.09))
pnorm(.86) + -pnorm(-3.09)
#'
#' @param Ho Null hypothesis
#' @param Ha Direction of the test, valid arguments are either "<", ">", or "!="
#' @param p True probability
#' @param n Sample size
#' @param alpha Significance level/Type I error probability/alpha level
#' @param sigma (Optional) population standard deviation
#' @return probability of Type II error
#' @export
#' Ha takes in either ">", "<", "!="
type2err <- function(Ho, Ha, p, n, alpha, sigma = NULL) {
if(is.null(sigma)) {
# 1-sided test with Ha = greater than some value
if(Ha == ">") {
z = qnorm(1 - alpha)
sd = sqrt(Ho * (1 - Ho)/n)
upper = Ho + z * sd
B = pnorm((upper - p)/sqrt(p * (1 - p)/n))
return(B)
}
else if(Ha == "<") {
z = qnorm(1 - alpha)
sd = sqrt(Ho * (1 - Ho)/n)
lower = Ho - z * sd
zLess = pnorm((lower - p)/sqrt(p * (1 - p)/n))
B = 1 - zLess
return(B)
}
else if(Ha == "!=") {
z = qnorm(1 - (alpha)/2)
sd = sqrt(Ho * (1 - Ho)/n)
lower = Ho - z * sd
upper = Ho + z * sd
zLess = pnorm((lower - p)/sqrt(p * (1 - p)/n))
zGreater = 1 - pnorm((upper - p)/sqrt(p * (1 - p)/n))
B = zGreater - zLess
return(B)
}
else {
return(cat(paste("Usage: please specify a valid Ha value\nOptions: Ha = \"<\", \">\", \"!=\"")))
}
}
# sigma given, working with numerical values
else {
if(Ha == ">") {
z = qnorm(1 - alpha)
sd = sigma/sqrt(n)
upper = Ho + z * sd
B = pnorm((upper - p)/sd)
return(B)
}
else if(Ha == "<") {
z = qnorm(1 - alpha)
sd = sigma/sqrt(n)
lower = Ho - z * sd
zLess = pnorm((lower - p)/sd)
B = 1 - zLess
return(B)
}
else if(Ha == "!=") {
z = qnorm(1 - (alpha)/2)
sd = sigma/sqrt(n)
lower = Ho - z * sd
upper = Ho + z * sd
zLess = pnorm((lower - p)/sqrt(p * (1 - p)/n))
zGreater = pnorm((upper - p)/sd)
B = zGreater - zLess
return(B)
}
else {
return(cat(paste("Usage: please specify a valid Ha value\nOptions: Ha = \"<\", \">\", \"!=\"")))
}
}
}
#2b.
Ho = 50000
n = 100
alpha = .1
sigma = 50000
samp_sd = sigma/sqrt(n)
p = 60000
z_score = qnorm(1 - alpha)
upper = Ho + z_score * samp_sd
pnorm((upper - p)/samp_sd)
type2err(Ho = Ho, Ha = ">", n = 100, p = 60000, alpha = .1, sigma = 50000)
Ho = .02
p = .03
n = 100 # ppl
# finding critical values with 95% confidence AKA alpha = .05
z = qnorm(.95) # == 1.645 USING .95 BECAUSE ITS A 1 SIDED TEST
sd = sqrt((Ho * (1 - Ho)/n))
upper = .02 + z*sd
upper
geq = 1 - pnorm((upper - p)/sqrt(p * (1 - p)/n))
B = 1 - (geq)
B
type2err(Ho = .02, Ha = ">", p = .03, n = 100, alpha = .05)
#'
#' @param Ho Null hypothesis
#' @param Ha Direction of the test, valid arguments are either "<", ">", or "!="
#' @param p True probability
#' @param n Sample size
#' @param alpha Significance level/Type I error probability/alpha level
#' @param sigma (Optional) population standard deviation
#' @return probability of Type II error
#' @export
#' Ha takes in either ">", "<", "!="
type2err <- function(Ho, Ha, p, n, alpha, sigma = NULL) {
if(is.null(sigma)) {
message("You have not specified a population sd. This is usually when working with probabilities.")
# 1-sided test with Ha = greater than some value
if(Ha == ">") {
z = qnorm(1 - alpha)
sd = sqrt(Ho * (1 - Ho)/n)
upper = Ho + z * sd
B = pnorm((upper - p)/sqrt(p * (1 - p)/n))
return(B)
}
else if(Ha == "<") {
z = qnorm(1 - alpha)
sd = sqrt(Ho * (1 - Ho)/n)
lower = Ho - z * sd
zLess = pnorm((lower - p)/sqrt(p * (1 - p)/n))
B = 1 - zLess
return(B)
}
else if(Ha == "!=") {
z = qnorm(1 - (alpha)/2)
sd = sqrt(Ho * (1 - Ho)/n)
lower = Ho - z * sd
upper = Ho + z * sd
zLess = pnorm((lower - p)/sqrt(p * (1 - p)/n))
zGreater = 1 - pnorm((upper - p)/sqrt(p * (1 - p)/n))
B = zGreater - zLess
return(B)
}
else {
return(cat(paste("Usage: please specify a valid Ha value\nOptions: Ha = \"<\", \">\", \"!=\"")))
}
}
# sigma given, working with numerical values
else {
if(Ha == ">") {
z = qnorm(1 - alpha)
sd = sigma/sqrt(n)
upper = Ho + z * sd
B = pnorm((upper - p)/sd)
return(B)
}
else if(Ha == "<") {
z = qnorm(1 - alpha)
sd = sigma/sqrt(n)
lower = Ho - z * sd
zLess = pnorm((lower - p)/sd)
B = 1 - zLess
return(B)
}
else if(Ha == "!=") {
z = qnorm(1 - (alpha)/2)
sd = sigma/sqrt(n)
lower = Ho - z * sd
upper = Ho + z * sd
zLess = pnorm((lower - p)/sqrt(p * (1 - p)/n))
zGreater = pnorm((upper - p)/sd)
B = zGreater - zLess
return(B)
}
else {
return(cat(paste("Usage: please specify a valid Ha value\nOptions: Ha = \"<\", \">\", \"!=\"")))
}
}
}
type2err(Ho = .02, Ha = ">", p = .03, n = 100, alpha = .05)
# 1e. find smallest sample size that will give type 2 error of .1 or less
minSampSizeType2 <- function(alpha, beta, Ho, Ha, twoSided = FALSE, sigma = NULL) {
if(!twoSided) {
message("You haven't specified a 2 or 1 sided test. The program defaults to a 1 sided test.")
}
if(is.null(sigma)) {
message("You have not specified a sd, this is when Ho and Ha are probabilities instead of numerical quantities.")
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = (((z_beta * sqrt(Ha * (1 - Ha))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - Ha))^2
return(n)
}
else if(!is.null(sigma)){
warning("nothing implemented for when sd is given")
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = ((z_alpha + z_beta)^2 * (sigma^2))/((Ho - Ha)^2)
return(n)
}
}
minSampSizeType2(alpha = .05, beta = .1, Ho = 50000, Ha = 60000, sigma = 50000)
# 1e. find smallest sample size that will give type 2 error of .1 or less
minSampSizeType2 <- function(alpha, beta, Ho, Ha, twoSided = FALSE, sigma = NULL) {
if(!twoSided) {
message("You haven't specified a 2 or 1 sided test. The program defaults to a 1 sided test.")
}
if(is.null(sigma)) {
message("You have not specified a sd, this is when Ho and Ha are probabilities instead of numerical quantities.")
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = (((z_beta * sqrt(Ha * (1 - Ha))) + (z_alpha * sqrt(Ho * (1 - Ho))))/(Ho - Ha))^2
return(n)
}
else if(!is.null(sigma)){
z_alpha = if(twoSided) qnorm(1 - (alpha/2)) else qnorm(1 - alpha)
z_beta = qnorm(1 - beta)
n = ((z_alpha + z_beta)^2 * (sigma^2))/((Ho - Ha)^2)
return(n)
}
}
minSampSizeType2(alpha = .05, beta = .1, Ho = 50000, Ha = 60000, sigma = 50000)
devtools::document()
rm(list = c("minSampSizeType2", "type2err"))
devtools::document()
cd ..
setwd()
getwd()
setwd("C:/Users/Alan/Documents/R-Workspace/collegestats")
setwd("C:/Users/Alan/Documents/R-Workspace")
devtools::install_github("azc242/collegestats")
